################################################################################
# The base Open Social schema                                                  #
#                                                                              #
# This file contains the basis of the Open Social GraphQL API Schema. It       #
# provides base types that can be used by individual Open Social features.     #
# Additionally it contains common interfaces for things such as pagination.    #
#                                                                              #
# Comments aimed at schema developers are prefixed with `#` and comments       #
# exposed to schema consumers are contained in `"""`.                          #
#                                                                              #
# If you're new to GraphQL I recommend starting at: https://graphql.org/learn/ #
################################################################################

# The actual GraphQL schema
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"""
The schema's entry-point for queries. This acts as the public, top-level API
from which all queries must start.
"""
type Query {
  """
  Get information about the currently authenticated user.

  NULL if you're not authenticated.
  """
  viewer : Actor
}

"""
The schema's entry-point for subscriptions. This acts as the public, top-level
API from which all subscriptions must start.

A real-time process must be implemented and deployed to support subscriptions.
"""
type Subscription

################################################################################
#                                Basic Types                                   #
################################################################################
"""
A concrete fetchable type that is addressable by an id.
"""
interface Node {
  id: ID!
}

"""
A valid version 4 UUID
"""
# This should not be used for entity UUIDs which should use ID instead.
# This can be used for user provided strings such as a clientMutationId.
scalar UUIDv4

"""
An access role for a user

Roles are used to assign groups of permissions to users on the platform.
"""
scalar UserRole

"""
A valid email address.
"""
scalar Email

"""
A valid URL
"""
scalar Url

"""
An HTML string

Content of this type is deemed safe by the server for raw output given the
origin and the context of its usage. The HTML can still contain scripts or style
tags where the creating user had permission to input these.
"""
scalar Html

"""
A UNIX timestamp.

The number of seconds since the Unix Epoch on January 1st, 1970 at UTC.
"""
scalar Timestamp

"""
A phone number.
"""
# For now we treat PhoneNumber as a special string but we may want to build it
# out to a proper type containing an country code and local number separately.
scalar PhoneNumber

# TODO: Add descriptions.
scalar TimeZone
scalar Language

"""
A longer string of text that may contain markup.
"""
type FormattedText {
  """
  The text format used by Open Social to process the input text.

  A text format provides information about what markup is allowed in the text.
  """
  format: TextFormat!
  """
  The raw string as used by an editor.
  """
  raw: String!
  """
  The string processed according to the text format.

  For a properly configured text format this string should be save to display
  to users.
  """
  processed: String!
}

"""
An Open Social text format.
"""
# Declared as separate type so that individual configurations may be exposed
# in the future if needed.
type TextFormat {
  """
  The machine name of the text format.
  """
  name: String!
#  """
#  The human readable name of the text format.
#  """
#  label: String!
}

"""
A date and time.
"""
type DateTime {
  """
  The date and time as UNIX timestamp.
  """
  timestamp: Timestamp!
}

"""
An actor is an entity that can perform actions and own content within Open Social.
"""
interface Actor implements Node {
  """
  The uuid of the Actor
  """
  id: ID!

  """
  The display name of the actor.
  """
  displayName: String!
}

################################################################################
#                                Media Types                                   #
#                                                                              #
# Media types provide the tools needed to manage media such as (video, image,  #
# audio and files).                                                            #
################################################################################
"""
A valid Data URI.
"""
# See https://en.wikipedia.org/wiki/Data_URI_scheme
scalar DataUri

"""
BlurHash is a compact representation of a placeholder for an image.

See https://blurha.sh/
"""
scalar BlurHash

"""
Media managed by the Open Social platform.
"""
interface Media implements Node {
  id: ID!
  """
  The url at which the original media can be downloaded.
  """
  url: Url!
}

type Image implements Media & Node {
  id: ID!
  """
  The location of the image as a URL.

  If no transform options are specified, then the original image will be preserved including any pre-applied transforms.

  All transformation options are considered "best-effort". Any transformation that the original image type doesn't support will be ignored.

  If you need multiple variations of the same image, then you can use [GraphQL aliases](https://graphql.org/learn/queries/#aliases).
  """
  url(transform: ImageTransformInput): Url!
  """
  Image Title
  """
  title: String!
  """
  Alt-text

  A description of the image that can be displayed as alternative when the image
  can't be loaded or to users who are unable to see the image itself.
  """
  alt: String!
  # @todo https://www.drupal.org/project/social/issues/3191640
  """
  The primary color in the image.

  Can be used to create a single-color placeholder while the image loads.
  """
  primaryColor: Color!
  """
  A blurred low quality version of the image in data uri format.

  Can be used to create a placeholder while the image loads.
  """
  blurUpThumb: DataUri!
}

"""
Available transform modes to scale images to the desired resolution.
"""
# This is a parameter that DatoCMS offered based on options available in imgix.
# I think providing control over how an image should be resized to fit the use-case is more
# powerful than a simple maxHeight and maxWidth that shopify did (that's why I chose `height`
# and `width`). I do think we should not offer all of their options. Since we want to keep
# control over what cropping experience we want to offer (and offer something predictable to
# users uploading images) we should omit any fit modes that affect how images are cropped.
# This leaves the following set of transforms (we can debate which one if any we want implement
# immediately and which one we want to implement later).
# See https://docs.imgix.com/apis/rendering/size/fit for all options
# Fill has been omitted since we don't have a fill color.
# Scale has been omitted because it distorts the image.
enum ImageTransformFit {
  """
  Resizes the image to fit within the width and height boundaries without cropping or distorting the image. The resulting image will match one of the constraining dimensions, while the other dimension is altered to maintain the same aspect ratio of the input image.
  """
  CLIP
}

"""
The available options for transforming an image.

All transformation options are considered "best-effort". Any transformation that the original image type doesn't support will be ignored.
"""
input ImageTransformInput {
  """
  Image height in pixels between 1 and 5760.
  """
  # Maximum  copied from Shopify. We can determine whether we want to copy their upper limit but enforcing one is a good idea.
  width: Int
  """
  Image width in pixels between 1 and 5760.
  """
  # Maximum  copied from Shopify. We can determine whether we want to copy their upper limit but enforcing one is a good idea.
  height: Int
  """
  Controls how the output image is fit to its target dimensions after resizing, and how any background areas will be filled.
  """
  fit: ImageTransformFit = CLIP
  """
  Convert the source image into the preferred content type. Supported conversions: .svg to .png, any file type to .jpg, and any file type to .webp.
  """
  # We can debate whether we want this. I do think Shopify's idea of limiting what transforms are supported is a good idea.
  preferredContentType: ImageContentType
  """
  Image size multiplier for high-resolution retina displays. Must be within 1..3.
  """
  scale: Int
}

enum ImageContentType {
  PNG
  JPG
  WEBP
}

"""
The file, can be used in attachments (txt, pdf, doc, docx, xls, xlsx, ppt, pptx, csv and etc.).
"""
type File implements Media & Node {
  id: ID!
  """
  The url at which the original file can be downloaded.
  """
  url: Url!
  """
  The name of the file.
  """
  filename: String!
  """
  The filemime type of the file.
  """
  filemime: String
  """
  The file size in bytes.
  """
  filesize: String
  """
  The timestamp indicating when the file was created.
  """
  created: DateTime!
}


# @todo https://www.drupal.org/project/social/issues/3191642

################################################################################
#                         Data Fetching Interfaces                             #
#                                                                              #
# All data fetching operations in Open Social should implement the Relay       #
# Connection specification: https://relay.dev/graphql/connections.htm          #
################################################################################
"""
A cursor for use in pagination.
"""
scalar Cursor

"""
An edge in a connection.

Provides the cursor to fetch data based on the position of the associated node.
Specific edge implementations may provide more information about the
relationship they represent.
"""
interface Edge {
  cursor: Cursor!
  node: Node!
}

# PageInfo deviates from the current Relay spec as in the spec the
# start-/endCursor fields may not be null. However, this is impractical because
# it does not account for empty results.
# See: https://github.com/facebook/relay/pull/2655
"""
Information about the page in a connection.
"""
type PageInfo {
  """
  Whether there are more pages in this connection.
  """
  hasNextPage: Boolean!
  """
  Whether there  are previous pages in this connection.
  """
  hasPreviousPage: Boolean!
  """
  The cursor for the first element in this page
  """
  startCursor: Cursor
  """
  The cursor for the last element in this page
  """
  endCursor: Cursor
}

"""
A paginated set of results.
"""
interface Connection {
  """
  The edges of this connection.
  """
  edges: [Edge!]!
  """
  The nodes of the edges of this connection.

  Provides direct access to the nodes in case other edge information
  isn't needed.
  """
  nodes: [Node!]!
  """
  Information to aid in pagination
  """
  pageInfo: PageInfo!
}


################################################################################
#                         Data Creation Interfaces                             #
################################################################################
"""
The base mutation type.
"""
type Mutation

"""
A violation indicates an error in the GraphQL query or other incorrect
circumstances such as missing permissions.
"""
scalar Violation

"""
The base GraphQL Response class
"""
interface Response {
  errors: [Violation]
}
